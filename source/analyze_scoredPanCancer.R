#analysis_scoredPanCancer.R
#Analyze scored datasets (i.e. results from analyze_scored.R), and compare across tumor types
#Author: Boyang Zhao
#DEPENDENCIES (datasets): 1) siglist_all (in sigListGene.RData, generated by analyze_scored.R)
#GENERATES: in 'dsetScoredSummary_dir' directory:
#               1) geneCounts_panCancer_*.csv
#               2) 'geneCounts.*' in geneCounts_panCancer.RData
#           in 'plots_dir' directory:
#               1) [plots pdf/png]

if(exists("config.avail") && config.avail){ #if configuration settings exist, keep these, clear the rest of workspace
  rm(list=ls()[grep("^[^config\\.].*$",ls())])
} else {
  rm(list=ls())
}

dset_dir <- "../datasets/"
dsetScored_dir <- paste(dset_dir, "scored/", sep="")
dsetScoredSummary_dir <- gettextf('%ssummary/summary_pval0.062_exprONLY_090415/', dsetScored_dir) #input directory
plots_dir <- gettextf('%splotsPanCancer_exprONLY_090415/', dsetScored_dir) #output directory
library(gplots)
library(ggplot2)
library(RColorBrewer)
library(reshape2)
source("util.R")

#settings
savePlots <- TRUE
saveLog <- TRUE
tumorTypesExclude <- c("CELLLINE", "ESCA", "PAAD", "LAML") #tumor types to exclude

#settings overwrite if configuration settings exist
if(exists("config.avail") && config.avail){
  dset_dir <- config.dset_dir
  dsetScored_dir <- config.dsetScored_dir
  dsetScoredSummary_dir <- config.dsetScoredSummary_dir
  plots_dir <- config.plotsPanCancer_dir
  
  savePlots <- config.pancancer.savePlots
  saveLog <- config.pancancer.saveLog
  tumorTypesExclude <- config.pancancer.tumorTypesExclude
}

#quality controls
checkDirExists(dsetScored_dir)
createDir(dsetScoredSummary_dir)
if(savePlots){
  createDir(plots_dir)
}

#load datasets
load(paste(dsetScoredSummary_dir,"sigListGene.RData",sep="")) #load in siglist_all
siglist_all <- siglist_all[!(siglist_all$tumorType %in% tumorTypesExclude),]
notExpr_all <- notExpr_all[!(notExpr_all$tumorType %in% tumorTypesExclude),]

#derived parameters
logFilename <- paste(dsetScoredSummary_dir,"analyze_scoredPanCancer.log",sep="")

#start diversion if applicable
if(saveLog){
  sink(logFilename, split=TRUE, append=FALSE)
}

###################################################
# Aggregate analysis methods
###################################################
parsegene <- function(gene, siglist=siglist, tumorTypes=tumorTypes){
  #helper method for creating frequency matrix
  #resulting matrix is a boolean matrix
  inTumors <- siglist[siglist$geneSymbol == gene, 'tumorType']
  boolMatrix <- tumorTypes %in% inTumors
}

parsegene_annot <- function(gene, siglist=siglist, tumorTypes=tumorTypes){
  #helper method for creating frequency matrix
  #resulting matrix is a score matrix
  #0=not significant, 1=significant only in MutSig, 2=significant only in probSig, 3=significant in both
  inTumors <- siglist[siglist$geneSymbol == gene, 'tumorType']
  boolMatrix <- tumorTypes %in% inTumors
  
  inTumors_MutSig <- siglist[siglist$geneSymbol == gene & siglist$MutSigPass,'tumorType']
  inTumors_probSig <- siglist[siglist$geneSymbol == gene & siglist$probPass,'tumorType']
  
  annotMatrix <- rep(0,length(tumorTypes))
  annotMatrix[(tumorTypes %in% inTumors_MutSig)] <- 1
  annotMatrix[(tumorTypes %in% inTumors_probSig)] <- 2
  annotMatrix[(tumorTypes %in% inTumors_MutSig)&(tumorTypes %in% inTumors_probSig)] <- 3
  
  return(annotMatrix)
}

genPanCancerPlots <- function(dataset,
                              title, #figure title
                              plot.dir, #plot directory
                              anotCol=brewer.pal(9,"PuBu"), #annotation color
                              hierclust=FALSE, #hierarchical clustering
                              topN=NULL, #only plot top N
                              countsCutoff=NULL, #only plot with counts cutoff at specified value
                              genesSelect=c(), #include the specified genes in list to plot (order preserved)
                              rowLabCutoff=30){ #maximum number of entries before turning off row label
  #helper method for creating frequency matrix and generate heatmaps
  
  select.idx <- 1:nrow(dataset)
  
  #get indices for reduced dataset, based on topN and/or countsCutoff, whichever lead to smaller dataset
  if(!is.null(countsCutoff)){
    counts <- apply(dataset>0,1,sum)
    countsCutoff.idx <- which(counts >= countsCutoff)
    select.idx <- countsCutoff.idx
  }
  
  if(!is.null(topN)){
    if(!is.null(countsCutoff)){
      if(topN < length(countsCutoff.idx)){
        select.idx <- 1:topN
      }
    } else {
      select.idx <- 1:topN
    }
  }
  
  genesSelect.idx <- c()
  #get indices for given genesSelect
  if(length(genesSelect)>1){
    genesSelect.idx <- match(genesSelect,rownames(dataset))
    if(sum(is.na(genesSelect.idx))>0){
      message("Some genes in geneSelect are not found in dataset. These are ignored for plotting purposes...")
      genesSelect.idx <- genesSelect.idx[!is.na(genesSelect.idx)]
    }
  }
  
  select.idx <- which(!(select.idx %in% genesSelect.idx))
  select.idx <- c(select.idx, genesSelect.idx)
  
  #if selection of a subset of dataset is specified, and the resulting dataset size is the same as the original
  #will not continue with the plot
  if(!is.null(topN) | !is.null(countsCutoff) | length(genesSelect)>1){
    if(length(select.idx) == nrow(dataset)){
      return(NULL)
    }
  }
  
  #select subset of dataset
  dataset <- dataset[select.idx,]
  
  #derived parameters
  counts <- apply(dataset>0,1,sum)
  dendrogramVal <- "none"
  if(hierclust){dendrogramVal <- "both"}
  
  #generate heatmap
  plotfn <- title
  openPDFdev(plot.dir, plotfn, savePlots)
  rowlabel <- rownames(dataset)
  if(!is.null(rowLabCutoff)){
    if(nrow(dataset)>rowLabCutoff){ rowlabel <- "" }
  }  
  par(cex.main=0.8)
  heatmap.2(dataset, main=plotfn, labRow=rowlabel, Colv=hierclust, Rowv=hierclust, dendrogram=dendrogramVal,
            density.info="none", trace="none", col=anotCol, key=FALSE,
            colsep=1:ncol(dataset), rowsep=1:nrow(dataset),
            sepwidth=c(0.001, 0.001), sepcolor=rgb(200,200,200,100,maxColorValue=255), cex.main=0.5)
  saveFig(plot.dir, plotfn, savePlots)
  dev.off()
  
  #generate bar plot of counts
  plotfn <- paste(title,"_barplot")
  openPDFdev(plot.dir, plotfn, savePlots)
  barplot(counts[length(counts):1], names.arg=rownames(dataset)[length(counts):1], horiz=T,las=2,cex.names=1)
  saveFig(plot.dir, plotfn, savePlots)
  dev.off()
}

aggregateAnalysis <- function(siglist,
                              filename,
                              plotReduced=TRUE, #will plot full dataset + a reduced dataset
                              topN=20,
                              countsCutoff=NULL, #cases count minimum cut-off
                              genesSelect=c(), #include the specified genes in list to plot (order preserved)
                              sortTumorTypes=TRUE, #sort columns (i.e. tumor type names)
                              hierclust=FALSE, #hierarchical clustering
                              useAnotCol=FALSE){ #use annotation colors
  #aggregate analysis of given siglist dataset
  #also generates a reduced heatmap for the top topN entries
  #REQUIRES: savePlots
  #OUTPUTS: writes .csv and returns sorted list of gene and corresponding counts (# of tumor types)
  
  catn(gettextf("Analyzing %s...",filename))
  
  colNon <- rgb(250,250,250,255,maxColorValue=255)
  colMutSig <- rgb(65,105,225,200,maxColorValue=255)
  colNovel <- rgb(178,34,34,200,maxColorValue=255)
  colNovelBoth <- rgb(230,171,2,maxColorValue=255)
  
  #quality controls
  if(length(siglist) < 1){
    message("Input dataset is empty. Nothing to analyze...")
  }
  
  #derived settings
  plotsSummary_dir <- paste(plots_dir, filename, sep="")
  
  #create plots folder
  if(savePlots){
    createDir(plotsSummary_dir)
  }
  if(useAnotCol){
    anotCol <- c(colNon, colMutSig, colNovel, colNovelBoth)
  } else {
    anotCol <- brewer.pal(9,"PuBu")
  }
  
  #get sorted list of genes mutated (count = number of tumor types)
  tumorTypes <- unique(siglist$tumorType)
  geneCounts <- aggregate(siglist$geneSymbol, by=list(siglist$geneSymbol), FUN=length)
  names(geneCounts) <- c('geneSymbol', 'count')
  idx<-order(-geneCounts$count)
  geneCounts.sorted <- geneCounts[idx,]
  
  #save sorted list
  catn("Saving sorted gene counts list...")
  write.csv(geneCounts.sorted,file=paste(dsetScoredSummary_dir, filename, ".csv",sep=""))
  
  #create frequency matrix
  if(useAnotCol){
    matchFreqMatrix <- vapply(geneCounts.sorted$geneSymbol, parsegene_annot, rep(0,length(tumorTypes)), siglist=siglist, tumorTypes=tumorTypes)
  } else {
    matchFreqMatrix <- vapply(geneCounts.sorted$geneSymbol, parsegene, rep(0,length(tumorTypes)), siglist=siglist, tumorTypes=tumorTypes)
  }
  matchFreqMatrix <- t(matchFreqMatrix)
  colnames(matchFreqMatrix) <- tumorTypes
  
  if(sortTumorTypes){
    idx<-order(colnames(matchFreqMatrix))
    matchFreqMatrix <- matchFreqMatrix[,idx]
  }
  
  #quality controls
  if(nrow(geneCounts.sorted) < 2){
    message("There are less than 2 genes in dataset. Cannot plot any heatmaps with this...")
  } else {
    #generate heatmap of all genes
    catn("Generating plots...")
    genPanCancerPlots(matchFreqMatrix, 'heatmap_all', plot.dir=plotsSummary_dir, anotCol=anotCol, 
                      hierclust=TRUE, rowLabCutoff=NULL)
    
    #generate heatmap of top set of genes
    if(plotReduced){
      genPanCancerPlots(matchFreqMatrix, 'heatmap_topN', plot.dir=plotsSummary_dir, anotCol=anotCol,
                        hierclust=FALSE, topN, countsCutoff, genesSelect)
    }
  }
  
  return(geneCounts.sorted)
}

aggregateECDF <- function(datasetExpr, datasetNotExpr){
  #generate ecdf of aggregated data, partitioned into expressed and expressed genes
  catn("Generating aggregate pval ecdf plot...")
  
  notExprAvail <- FALSE
  if(!is.null(datasetNotExpr)){
    notExprAvail <- TRUE
    datasetNotExpr <- datasetNotExpr[!is.na(datasetNotExpr$qval_prob),] #remove NAs
  }
  
  datasetExpr <- datasetExpr[!is.na(datasetExpr$qval_prob),] #remove NAs
  
  
  plotfn <- 'pval_ecdf'
  openPDFdev(plots_dir, plotfn, savePlots, height=4, width=8)
  g <- NULL
  if(notExprAvail){
    dToPlot <- melt(list(expressed=datasetExpr$qval_prob,notexpressed=datasetNotExpr$qval_prob))
    #gline <- geom_vline(xintercept=min(datasetNotExpr$pval_prob),linetype=2,size=0.8,color="#66676E")
    #gline <- geom_vline(xintercept=0.06217,linetype=2,size=0.8,color="#66676E")
    #gline <- geom_vline(xintercept=0.06, linetype=2,size=0.8,color="#66676E")
    g <- ggplot(dToPlot, aes(value,group=L1,color=L1)) #+ gline
  }
  if(is.null(g)){
    dToPlot <- melt(list(expressed=datasetExpr$qval_prob))
    g <-ggplot(dToPlot, aes(value,group=L1,color=L1))
  }
  gh <- g + stat_ecdf(size=0.8) + labs(x="Adjusted p-value (prob)", y="eCDF", color="Pan-Cancer") + 
    ylim(0,1) + scale_x_log10() + theme(legend.position=c(0,1),legend.justification=c(0,1))
  print(gh)
  saveFig(plots_dir, plotfn, savePlots, height=500, width=900)
  dev.off()
}

###################################################
# Pan-Cancer analyses
###################################################
tryCatch({
  
  siglist_all$MutSigPass <- as.logical(siglist_all$MutSigPass)
  siglist_all$probPass <- as.logical(siglist_all$probPass)
  
  #aggregate analysis for all genes in siglist_all
  geneCounts.all <- aggregateAnalysis(siglist_all, "geneCounts_panCancer_all")
  
  #aggregate analysis for all genes that pass prob and MutSig criteria
  geneCounts.probMutSigPass <- aggregateAnalysis(siglist_all[siglist_all$MutSigPass | siglist_all$probPass,], 
                                                 "geneCounts_panCancer_allPass", useAnotCol=TRUE)
  
  #aggregate analysis for all genes that pass prob and MutSig criteria + at least one exact match
  #with color scheme annotated and select genes
  genesToInclude <- unique(siglist_all[!is.na(siglist_all$prob),'geneSymbol']) 
  geneCounts.probMutSigPass <- aggregateAnalysis(siglist_all[siglist_all$geneSymbol %in% genesToInclude &
                                                               (siglist_all$MutSigPass | siglist_all$probPass),], 
                                                 "geneCounts_panCancer_allPass_withAtLeastOneExactMatch", useAnotCol=TRUE)
  
  #aggregate analysis for all genes that pass prob and MutSig criteria + at least one exact match
  #with color scheme annotated and select genes
  genesToInclude <- unique(siglist_all[siglist_all$probPass,'geneSymbol']) 
  geneCounts.probMutSigPass <- aggregateAnalysis(siglist_all[siglist_all$geneSymbol %in% genesToInclude &
                                                               (siglist_all$MutSigPass | siglist_all$probPass),], 
                                                 "geneCounts_panCancer_allPass_withAtLeastOneProbPass", useAnotCol=TRUE)
  
  #aggregate analysis for all genes that pass MutSig criteria
  geneCounts.MutSigPass <- aggregateAnalysis(siglist_all[siglist_all$MutSigPass,], 
                                             "geneCounts_panCancer_MutSigPass")
  
  #aggregate analysis for all genes that pass prob criteria
  geneCounts.probPass <- aggregateAnalysis(siglist_all[siglist_all$probPass,], 
                                           "geneCounts_panCancer_probPass")
  
  #aggregate analysis for all genes that pass prob and MutSig criteria, with color scheme annotated and select genes
  noonanGenes <- c("PTPN11","SOS1","RAF1","KRAS","BRAF","CBL","NRAS")
  survivalGenes <- c("COL3A1","GNRHR")
  aggregateAnalysis(siglist_all[siglist_all$MutSigPass | siglist_all$probPass,], 
                    "panCancer_selectList", useAnotCol=TRUE,
                    topN=NULL, countsCutoff=2, genesSelect=c(noonanGenes,survivalGenes))
  
  #aggregate analysis for all genes that pass prob and MutSig criteria + at least one exact match
  #with color scheme annotated and select genes
  genesToInclude <- unique(siglist_all[!is.na(siglist_all$prob),'geneSymbol']) 
  aggregateAnalysis(siglist_all[siglist_all$geneSymbol %in% genesToInclude &
                                  (siglist_all$MutSigPass | siglist_all$probPass),],
                    "panCancer_selectList_withAtLeastOneExactMatch", useAnotCol=TRUE,
                    topN=NULL, countsCutoff=2, genesSelect=c(noonanGenes,survivalGenes))
  
  #aggregate analysis for all genes that pass prob and MutSig criteria + at least one prob pass
  #with color scheme annotated and select genes
  genesToInclude <- unique(siglist_all[siglist_all$probPass,'geneSymbol']) 
  aggregateAnalysis(siglist_all[siglist_all$geneSymbol %in% genesToInclude &
                                  (siglist_all$MutSigPass | siglist_all$probPass),],
                    "panCancer_selectList_withAtLeastOneProbPass", useAnotCol=TRUE,
                    topN=NULL, countsCutoff=2, genesSelect=c(noonanGenes,survivalGenes))
  
  aggregateECDF(siglist_all, notExpr_all)
  
  #save results
  save(geneCounts.all, geneCounts.probMutSigPass, geneCounts.MutSigPass, geneCounts.probPass,
       file=paste(dsetScoredSummary_dir,"geneCounts_panCancer.RData",sep=""))
  
}, warning = function(w){
  message(conditionMessage(w))
}, error = function(err){
  message(conditionMessage(err))
}, finally = {
  if(saveLog){
    sink() #close diversion
  }
})
